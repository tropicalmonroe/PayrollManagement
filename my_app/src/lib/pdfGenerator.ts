import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';

// Brand colors - AD Capital blue (matching app theme)
export const BRAND_COLORS = {
  primary: '#3b82f6', // AD Capital blue (hsl(221.2 83.2% 53.3%))
  secondary: '#f8fafc',
  text: '#1e293b',
  lightText: '#64748b',
  border: '#e2e8f0',
  success: '#10b981',
  warning: '#f59e0b',
  error: '#ef4444'
};

// PDF configuration
export const PDF_CONFIG = {
  pageSize: 'A4' as const,
  margins: {
    top: 50,
    right: 50,
    bottom: 50,
    left: 50
  }
};

export class PDFGenerator {
  private doc: any;
  private currentY: number;
  private pageWidth: number;
  private pageHeight: number;
  private margin: number;
  private pageNumber: number;

  constructor() {
    this.doc = new PDFDocument({ 
      size: 'A4',
      margins: PDF_CONFIG.margins,
      info: {
        Title: 'Document RH',
        Author: 'AD Capital',
        Subject: 'Document generated by AD Capital Payroll System',
        Creator: 'AD Capital Payroll System'
      }
    });
    
    this.pageWidth = this.doc.page.width;
    this.pageHeight = this.doc.page.height;
    this.margin = PDF_CONFIG.margins.left;
    this.currentY = this.margin;
    this.pageNumber = 1;

    // Set up automatic page handling
    this.doc.on('pageAdded', () => {
      this.pageNumber++;
      this.currentY = this.margin;
    });
  }

  // Add professional header with company branding
  addHeader(title: string, subtitle?: string) {
    const headerHeight = 80;
    
    try {
      // Try to add the actual logo image
      const logoPath = path.join(process.cwd(), 'public', 'image001.png');
      if (fs.existsSync(logoPath)) {
        // Add logo image
        this.doc.image(logoPath, this.margin, this.currentY, {
          width: 120,
          height: 40,
          fit: [120, 40],
          align: 'center',
          valign: 'center'
        });
      } else {
        // Fallback: Company logo area with AD Capital branding
        this.doc
          .rect(this.margin, this.currentY, 120, 40)
          .fillAndStroke(BRAND_COLORS.primary, BRAND_COLORS.primary);
        
        // Company name in white
        this.doc
          .fillColor('#ffffff')
          .fontSize(16)
          .font('Times-Bold')
          .text('AD Capital', this.margin + 10, this.currentY + 10);
        
        this.doc
          .fontSize(12)
          .font('Helvetica')
          .text('Payroll Management', this.margin + 10, this.currentY + 28);
      }
    } catch (error) {
      // Fallback: Company logo area with AD Capital branding
      this.doc
        .rect(this.margin, this.currentY, 120, 40)
        .fillAndStroke(BRAND_COLORS.primary, BRAND_COLORS.primary);
      
      // Company name in white
      this.doc
        .fillColor('#ffffff')
        .fontSize(16)
        .font('Helvetica-Bold')
        .text('AD Capital', this.margin + 10, this.currentY + 10);
      
      this.doc
        .fontSize(12)
        .font('Helvetica')
        .text('Payroll Management', this.margin + 10, this.currentY + 28);
    }

    // Document title
    this.doc
      .fillColor(BRAND_COLORS.text)
      .fontSize(20)
      .font('Helvetica-Bold')
      .text(title, this.margin + 140, this.currentY + 10, {
        width: this.pageWidth - this.margin - 140 - this.margin,
        align: 'left'
      });

    // Subtitle if provided
    if (subtitle) {
      this.doc
        .fillColor(BRAND_COLORS.lightText)
        .fontSize(14)
        .font('Helvetica')
        .text(subtitle, this.margin + 140, this.currentY + 35);
    }

    // Horizontal line separator with AD Capital blue
    this.currentY += headerHeight;
    this.doc
      .strokeColor(BRAND_COLORS.primary)
      .lineWidth(2)
      .moveTo(this.margin, this.currentY)
      .lineTo(this.pageWidth - this.margin, this.currentY)
      .stroke();

    this.currentY += 20;
  }

  // Add professional footer
  addFooter() {
    const footerY = this.pageHeight - this.margin - 30;
    
    // Footer line
    this.doc
      .strokeColor(BRAND_COLORS.border)
      .lineWidth(0.5)
      .moveTo(this.margin, footerY)
      .lineTo(this.pageWidth - this.margin, footerY)
      .stroke();

    // Page number
    this.doc
      .fillColor(BRAND_COLORS.lightText)
      .fontSize(10)
      .font('Helvetica')
      .text(`Page ${this.pageNumber}`, this.pageWidth - this.margin - 50, footerY + 10, {
        width: 50,
        align: 'right'
      });

    // Generation date
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    this.doc.text(`Generated on ${dateStr}`, this.margin, footerY + 10);

    // Company info
    this.doc
      .fontSize(8)
      .text('Â© 2025 AD Capital - Payroll Management System', this.margin, footerY + 20);
  }

  // Add section title with professional styling
  addSectionTitle(title: string, marginTop: number = 15) {
    this.checkPageBreak(30);
    this.currentY += marginTop;
    
    // Background for section title
    this.doc
      .rect(this.margin, this.currentY - 5, this.pageWidth - (this.margin * 2), 25)
      .fillAndStroke(BRAND_COLORS.secondary, BRAND_COLORS.border);
    
    this.doc
      .fillColor(BRAND_COLORS.primary)
      .fontSize(14)
      .font('Helvetica-Bold')
      .text(title, this.margin + 10, this.currentY + 5);
    
    this.currentY += 30;
  }

  // Add key-value pairs with proper alignment
  addKeyValue(key: string, value: string | number, options?: { 
    fontSize?: number; 
    bold?: boolean;
    color?: string;
  }) {
    const fontSize = options?.fontSize || 11;
    const font = options?.bold ? 'Helvetica-Bold' : 'Helvetica';
    const color = options?.color || BRAND_COLORS.text;
    
    this.checkPageBreak(20);
    
    this.doc
      .fillColor(color)
      .fontSize(fontSize)
      .font(font)
      .text(`${key}:`, this.margin, this.currentY, { continued: true })
      .font('Helvetica')
      .text(` ${value}`, { align: 'left' });
    
    this.currentY += fontSize + 3;
  }

  // Add professional table with proper formatting
  addTable(headers: string[], rows: (string | number)[][], options?: {
    headerBgColor?: string;
    headerTextColor?: string;
    alternateRowColor?: string;
    fontSize?: number;
  }) {
    const fontSize = options?.fontSize || 10;
    const tableWidth = this.pageWidth - (this.margin * 2);
    const colWidth = tableWidth / headers.length;
    const rowHeight = 20;
    const headerHeight = 25;

    this.checkPageBreak(headerHeight + (rows.length * rowHeight) + 20);

    // Table header
    this.doc
      .rect(this.margin, this.currentY, tableWidth, headerHeight)
      .fillAndStroke(options?.headerBgColor || BRAND_COLORS.primary, BRAND_COLORS.primary);
    
    this.doc
      .fillColor(options?.headerTextColor || '#ffffff')
      .fontSize(fontSize)
      .font('Helvetica-Bold');
    
    headers.forEach((header, index) => {
      const x = this.margin + (index * colWidth) + 5;
      this.doc.text(header, x, this.currentY + 8, {
        width: colWidth - 10,
        align: 'left',
        ellipsis: true
      });
    });
    
    this.currentY += headerHeight;

    // Table rows
    rows.forEach((row, rowIndex) => {
      // Check if we need a new page
      if (this.currentY + rowHeight > this.pageHeight - this.margin - 50) {
        this.addFooter();
        this.doc.addPage();
        this.currentY = this.margin + 20;
      }

      // Alternate row colors
      if (rowIndex % 2 === 1 && options?.alternateRowColor) {
        this.doc
          .rect(this.margin, this.currentY, tableWidth, rowHeight)
          .fillAndStroke(options.alternateRowColor, options.alternateRowColor);
      }

      this.doc
        .fillColor(BRAND_COLORS.text)
        .fontSize(fontSize)
        .font('Helvetica');
      
      row.forEach((cell, cellIndex) => {
        const x = this.margin + (cellIndex * colWidth) + 5;
        this.doc.text(String(cell), x, this.currentY + 6, {
          width: colWidth - 10,
          align: 'left',
          ellipsis: true
        });
      });
      
      this.currentY += rowHeight;
    });

    // Table border
    this.doc
      .strokeColor(BRAND_COLORS.border)
      .lineWidth(0.5)
      .rect(this.margin, this.currentY - (rows.length * rowHeight) - headerHeight, tableWidth, (rows.length * rowHeight) + headerHeight)
      .stroke();
    
    // Column separators
    for (let i = 1; i < headers.length; i++) {
      const x = this.margin + (i * colWidth);
      this.doc
        .moveTo(x, this.currentY - (rows.length * rowHeight) - headerHeight)
        .lineTo(x, this.currentY)
        .stroke();
    }

    // Row separators
    for (let i = 0; i <= rows.length; i++) {
      const y = this.currentY - (rows.length * rowHeight) + (i * rowHeight);
      this.doc
        .moveTo(this.margin, y)
        .lineTo(this.pageWidth - this.margin, y)
        .stroke();
    }

    this.currentY += 15;
  }

  // Add professional summary box
  addSummaryBox(title: string, items: { label: string; value: string | number; highlight?: boolean }[]) {
    const boxHeight = (items.length * 18) + 40;
    this.checkPageBreak(boxHeight + 10);

    const boxWidth = this.pageWidth - (this.margin * 2);

    // Box background and border
    this.doc
      .rect(this.margin, this.currentY, boxWidth, boxHeight)
      .fillAndStroke(BRAND_COLORS.secondary, BRAND_COLORS.border);

    // Title background
    this.doc
      .rect(this.margin, this.currentY, boxWidth, 30)
      .fillAndStroke(BRAND_COLORS.primary, BRAND_COLORS.primary);

    // Title text
    this.doc
      .fillColor('#ffffff')
      .fontSize(12)
      .font('Helvetica-Bold')
      .text(title, this.margin + 10, this.currentY + 10);

    let itemY = this.currentY + 40;

    // Items
    items.forEach(item => {
      const fontSize = item.highlight ? 12 : 11;
      const font = item.highlight ? 'Helvetica-Bold' : 'Helvetica';
      const color = item.highlight ? BRAND_COLORS.primary : BRAND_COLORS.text;
      
      this.doc
        .fillColor(color)
        .fontSize(fontSize)
        .font(font)
        .text(`${item.label}:`, this.margin + 10, itemY);
      
      // Right-align the value
      this.doc.text(String(item.value), this.margin + 10, itemY, {
        width: boxWidth - 20,
        align: 'right'
      });
      
      itemY += 18;
    });

    this.currentY += boxHeight + 15;
  }

  // Add paragraph with proper text wrapping
  addParagraph(text: string, options?: { 
    fontSize?: number; 
    color?: string; 
    align?: 'left' | 'center' | 'right';
    font?: string;
  }) {
    const fontSize = options?.fontSize || 11;
    const color = options?.color || BRAND_COLORS.text;
    const align = options?.align || 'left';
    const font = options?.font || 'Helvetica';

    this.checkPageBreak(50);

    this.doc
      .fillColor(color)
      .fontSize(fontSize)
      .font(font)
      .text(text, this.margin, this.currentY, {
        width: this.pageWidth - (this.margin * 2),
        align: align,
        lineGap: 2
      });

    // Calculate text height to update currentY
    const textHeight = this.doc.heightOfString(text, {
      width: this.pageWidth - (this.margin * 2)
    });
    
    this.currentY += textHeight + 10;
  }

  // Check if we need a new page
  checkPageBreak(requiredSpace: number = 50): boolean {
    if (this.currentY + requiredSpace > this.pageHeight - this.margin - 50) {
      this.addFooter();
      this.doc.addPage();
      this.currentY = this.margin + 20;
      return true;
    }
    return false;
  }

  // Add space
  addSpace(space: number = 10) {
    this.currentY += space;
  }

  // Get the PDF as buffer (async method)
  async getBuffer(): Promise<Buffer> {
    this.addFooter();
    
    return new Promise<Buffer>((resolve, reject) => {
      const buffers: Buffer[] = [];
      
      this.doc.on('data', (chunk: Buffer) => {
        buffers.push(chunk);
      });
      
      this.doc.on('end', () => {
        resolve(Buffer.concat(buffers));
      });
      
      this.doc.on('error', (err: Error) => {
        reject(err);
      });
      
      this.doc.end();
    });
  }

  // Get the PDF as base64
  async getBase64(): Promise<string> {
    const buffer = await this.getBuffer();
    return buffer.toString('base64');
  }
}

// Utility functions for formatting
export const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('en-KE', {
    style: 'currency',
    currency: 'KES',
    minimumFractionDigits: 2
  }).format(amount);
};

export const formatDate = (date: Date | string): string => {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('en-KE').format(num);
};
